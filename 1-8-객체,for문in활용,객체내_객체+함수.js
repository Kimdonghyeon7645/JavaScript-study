/*
객체 (Object) :
자바스크립트에서 객체는 배열과 비슷한데, 차이점이라면, 
배열은 인덱스를 이용해서 각각의 데이터를 식별한다면, 객체는 각각의 문자를 이용해서 각각의 데이터를 식별한다.
(배열 - 인덱스:데이터, 객체 - 키(문자):데이터) 다른언어에선 연관배열, 맵, 딕셔너리(dict)에서 쓰이던 것이 js의 객체다.

이 객체는 나중에 객체지향 프로그램에서 요긴하게 쓰이는데, 
여기선 일단 데이터를 담아내는 컨테이너(그릇, 용기)로써의 객체를 설명하는 것이기에 객체지향적 내용은 생략한다. (나중에 객체지향 정리로 따로 올릴 예정)
*/

var score = {'국어': 81, '수학': 89, '자료구조': 100, '영어': 68}
var food = {        // 위같이 {} 안이라면, 안에서 엔터로 각각의 요소를 구분해도 된다.
    'pizza': '피자',
    'fork': '삼겹살',
    'beef': '소고기',
    'hamburger': '햄버거',
    'soda': '탄산음료'
}
var ob1 = {}    // 빈객체 생성
var ob2 = new Object();     // 마찬가지로 빈 객체 생성 
/*
객체는 위같은 방법들로 만들 수 있다.
{} 안에 '키':'값' 과 같이 하면, 인덱스:값 처럼 키에 매칭되는 값을 객체에 만들 수 있다. 
{} 만 하면 그냥 빈 객체가 되고, new Object() 같이 해도 마찬가지다. (이것에 대한 자세한 구문은 객체지향 정리 참고)
이렇게 만든 객체를 변수에다 대입해주면, 객체를 변수에 담아서 사용할 수 있다.


그리고 이러한 객체안의 값은 배열에서
배열[인덱스]
로 접근했듯이 객체도,
객체[키]
로 값을 접근 할 수 있다. 그리고 여기에 추가로,
객체.키
같이 해서 똑같이 값을 접근 할 수 있다. 
*/
alert(score['국어'])        // 배열[키] 로 접근
alert(score.수학)           // 배열.키 로 접근
alert(score['수'+'학'])     // 이렇게 키를 넣어줘도 가능
//  alert(score.영+어)      // 대신에 이렇게는 할 수 없음


score['영어'] = 80  // 이미 있는 키 이므로,(영어) 이와 매칭되는 값(68)을 새로운 값(80)으로 수정
ob1['a'] = 'abc'    // 없던 키 이므로,(a) 새로운 값(abc) 와 함께 키: 값 형태로 추가
/*
그리고 접근한 값에서 값을 대입해서 값을 수정할 수 있고,
배열[키] = 값
에서 키가 이전에 있던 키가 아닐경우는, 키에 대한 값이 수정되지 않고, 새로 추가한 키:값 형태가 해당 배열에 추가된다.
*/


li = ['가', '나', '다']
for(i in li){
    document.write('인덱스 값 : ' + i + ',  value 값: ' + li[i] + '<br>')
}
document.write('<br>')  
//  document.write()함수에 <br>를 문자열로 문서에 쓰면, 실제 태그로 역할을 수행
//  나중에 document.write()함수를 다루겠지만, 이를 이용해서 <li> </li> 문자열을 양 끝에 추가해서 리스트 항목으로 문서에 쓰게 할 수 있음.
for(key in score) {
    document.write('key 값 : ' + key + ',  value 값: ' + score[key] + '<br>')    
}
/* for 문에서 in 사용하기

사실 배열과 객체같이 여러 요소들이 모인 값을 
for (변수 in (배열or객체)) {}
같이 조건문에 넣어주고, 그 앞에 변수 in 을 넣어주면, 배열 or 객체의 요소를 순서대로 하나씩 뽑아서,
그 요소의 인덱스 or 키를 in 앞에 있는 변수에 대입해준다. 그리고 더이상 배열 or 객체에 뽑아낼 요소가 없으면(마지막 요소까지 뽑아내 반복한 경우,) 반복문을 종료한다.
(파이썬에서 쓰던 for i in range(10): 같은 문법과 똑같다.)

이렇게 하면, 배열 or 객체의 요소 개수만큼 반복문이 실행되며,
각각의 반복마다, 배열이면 배열의 인덱스, 객체면 객체의 키가 조건문의 변수에 저장되서, 그 변수를 for문 {}안 코드에서 접근하고 사용할 수 있다.
*/

gogo = {
    'title': 'gogo 객체! <br>',
    'list': {'a': 1, 'b': 2, 'c': 3, 'd': 4},
    'func': function(){
        document.write('gogo 객체의 func 요소를 불러서, 이 함수를 실행! <br>')
    },
    'show_gogo': function(){
        for(var k in this.list){
            document.write('<p>key:' + k + ',  value:' + this.list[k] + '</p>')
        }
    }
}

// 객체안의 그냥 요소를 참조할 때
document.write(gogo.title);
document.write(gogo['title'])

// 객체안의 객체안 요소를 참조할 때
alert(gogo['list']['a'])
alert(gogo['list'].b)
alert(gogo.list['c'])
alert(gogo.list.d)

// 객체안의 함수를 호출할 때
gogo.func();
document.write(gogo.func);     // 이렇게 객체의 함수를 호출하지 않고 정의한 구문을 출력하게 만들 수도 있는듯...
gogo.show_gogo();

/* 객체에 객체, 함수 담기
객체는 사실 문자, 숫자 같은 값 말고도, 다른 객체나, 함수도 요소로 들어 갈 수 있다.
키:값 
에서 값을 객체로 놓거나, 값을 함수의 정의 형식으로 놓을 수 있는 것이다.
이런 객체안의 객체를 접근할 때도, 마찬가지로,
객체.객체[키] or 객체.객체.키 or 객체[객체][키] or 객체[객체].키
같이해서 . or []를 중첩해서 사용하면 된다.

그리고 객체안의 함수는 
객체.키()
같이해서 키에 해당되는 값(함수)를 호출할 수 있다.


추가로 객체 안에서는 this 라는 키워드를 사용할 수 있는데, this 는 객체 자기 자신을 의미한다.

솔직히 객체에 객체, 함수를 넣고 this 를 사용하는 것 같은 것은 
객체안에서 속성과 메서드를 담을 수 있다는, 객체지향과 연관된 내용이다.
그리고 이렇게 하나의 객체안에 연관된 요소, 객체, 배열, 함수등을 넣어 놓는 걸 객체지향 프로그래밍이라 한다. 
이런 객체지향적 내용은 이제 나중에 객체지향 정리를 할때 자세히 다루겠다.
*/