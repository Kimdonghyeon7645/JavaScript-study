var a = 1
var b = a
console.log(a, b)   // 1 1
b = 2
console.log(a, b)   // 1 2
/*
위 코드는 a 변수를 선언+정의하고, b 변수를 선언할 때, a의 값으로 정의했다.
이것이 복제(복사)다, 당연하게 b에는 a의 값이 출력되며, b의 값을 바꾸면 b에만 바꾼 값이 반영된다.
이러한 구조는, a와 b 변수 따로 따로 각자의 저장공간을 가지는 구조인데, 

참조는 위와는 다르다.
*/

var x = {'id': 1}
var y = x
console.log(x, y)   // { id: 1 } { id: 1 }
y.id = 2
console.log(x, y)   // { id: 2 } { id: 2 }
/*
복제와 달리 참조(reference)는, x의 값을, y가 복제해서 y만의 공간에 저장하는 것이 아니라,
y가 x의 공간을 같이 참조하는 구조다. (마치 윈도우에서의 바로가기 아이콘과 같다)

맨 처음에서 복제한 숫자처럼, 
데이터 타입이 원시 데이터 타입(기본 데이터 타입, Primitive Data)이면 복제가 되지만,
위같이 원시 데이터 타입이 아닌 값, 다시말해 객체라면 복제가 되지 않고 참조가 된다.
그래서 객체를 참조 데이터 형(참조 자료형)이라고도 부른다.
*/

// 함수의 매개변수
var ob1 = {'id': 1}
function func1(ob2){
    ob2 = {'id': 2}
}
func1(ob1)
console.log(ob1)
/*
원시 데이터 타입을 매개변수로 전달받으면, 복제가 되겠지만,
객체를 매개변수로 전달받을 때는, 매개변수는 인자값을 참조하는 변수가 된다.

여기서 매개변수(ob2)에 다른 객체({'id': 2})를 대입하면, 
매개변수(ob2)는 가리키던 대상(객체)을 원래 전달받은 인자값(ob1)에서 대입받은 객체({'id': 2})로 변경한다.
그래서 원래 인자값(ob1)의 값에는 영향이 없다.
*/

function func2(ob3){
    ob3.id = 3
}
func2(ob1)
console.log(ob1)
/*
대신에 매개변수(ob3)의 속성(.id)을 변경하면(3),
매개변수가 가리키던 원래 객체(ob1)의 속성을 수정하는 것이 되서, 
원래 인자값(ob1)의 값에도 영향이 간다.
*/